<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Breath Retention</title>
  <link rel="icon" type="image/png" href="./favicon.png?v=2" />
  <link rel="apple-touch-icon" href="./apple-touch-icon.png" />
  <link rel="manifest" href="./manifest.json" />
  <meta name="theme-color" content="#1e3a5f" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="mobile-web-app-capable" content="yes" />
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&family=Poiret+One&display=swap');

    :root {
      /* Sky gradient colors - cool blue palette */
      --sky-top: #0d1b3e;
      --sky-mid-1: #1e3a5f;
      --sky-mid-2: #2d5a87;
      --sky-light: #4a90b8;
      --sky-pale: #7ec8e3;
      --sky-horizon: #b8e4f0;
      --sky-lavender: rgba(130, 150, 200, 0.3);
      
      /* Cloud haze - cool whites and pale blues */
      --cloud-1: rgba(255, 255, 255, 0.45);
      --cloud-2: rgba(230, 245, 255, 0.4);
      --cloud-3: rgba(200, 230, 255, 0.35);
      
      /* Rainbow shimmer gradient (comet-inspired) */
      --rainbow-gradient: linear-gradient(
        135deg,
        rgba(0, 229, 255, 0.8) 0%,
        rgba(100, 181, 246, 0.8) 20%,
        rgba(149, 117, 205, 0.8) 40%,
        rgba(240, 98, 146, 0.8) 60%,
        rgba(255, 138, 128, 0.8) 80%,
        rgba(255, 183, 77, 0.8) 100%
      );
      --rainbow-border: linear-gradient(
        135deg,
        #00e5ff 0%,
        #64b5f6 25%,
        #9575cd 50%,
        #f06292 75%,
        #ffb74d 100%
      );
      
      /* Liquid glass */
      --glass-bg: rgba(255, 255, 255, 0.35);
      --glass-border: rgba(255, 255, 255, 0.5);
      --glass-highlight: rgba(255, 255, 255, 0.75);
      --glass-shadow: rgba(13, 27, 62, 0.25);
      --glass-blur: 16px;
      
      /* Text - darker for contrast on lighter elements */
      --text: #0d1b3e;
      --text-muted: #1e3a5f;
      --text-soft: #2d5a87;
      --danger: #d32f2f;
      
      /* Bubble */
      --bubble-rim: rgba(255, 255, 255, 0.8);
      --bubble-highlight: rgba(255, 255, 255, 0.98);
      --bubble-sheen-1: rgba(0, 229, 255, 0.35);
      --bubble-sheen-2: rgba(240, 98, 146, 0.3);
      --bubble-sheen-3: rgba(255, 183, 77, 0.25);
      --bubble-inner: rgba(255, 255, 255, 0.2);
      --mist-alpha: 0.08;
      
      /* Misc */
      --radius: 20px;
      --radius-pill: 999px;
      --font: 'Montserrat', ui-sans-serif, system-ui, -apple-system, sans-serif;
      --transition-fast: 0.15s ease;
      --transition-med: 0.3s ease;
      
      /* Breathing text scale */
      --text-scale: 1;
    }

    * { 
      box-sizing: border-box; 
      -webkit-tap-highlight-color: transparent; 
    }
    
    html, body { 
      height: 100%; 
    }

    body {
      margin: 0;
      font-family: var(--font);
      color: var(--text);
      overflow-x: hidden;
      
      /* Anime sky background - cool blue palette */
      background: 
        /* Subtle grain via layered gradients */
        repeating-linear-gradient(
          0deg,
          transparent,
          transparent 3px,
          rgba(255, 255, 255, 0.015) 3px,
          rgba(255, 255, 255, 0.015) 6px
        ),
        /* Cloud haze - large soft ellipses */
        radial-gradient(ellipse 130% 70% at 15% 25%, var(--cloud-1), transparent 55%),
        radial-gradient(ellipse 110% 90% at 80% 20%, var(--cloud-2), transparent 50%),
        radial-gradient(ellipse 160% 60% at 50% 85%, var(--cloud-3), transparent 55%),
        /* Cool atmospheric haze */
        radial-gradient(ellipse 90% 80% at 5% 60%, var(--sky-lavender), transparent 55%),
        radial-gradient(ellipse 70% 60% at 95% 50%, rgba(100, 150, 200, 0.2), transparent 50%),
        /* Soft light glow */
        radial-gradient(ellipse 80% 70% at 50% 90%, rgba(180, 220, 255, 0.25), transparent 50%),
        /* Base sky gradient - deep blue to pale blue */
        linear-gradient(
          180deg,
          var(--sky-top) 0%,
          var(--sky-mid-1) 20%,
          var(--sky-mid-2) 40%,
          var(--sky-light) 60%,
          var(--sky-pale) 80%,
          var(--sky-horizon) 100%
        );
      background-attachment: fixed;
      min-height: 100vh;
    }

    .wrap {
      min-height: 100%;
      padding: 16px;
      padding-bottom: max(16px, env(safe-area-inset-bottom));
      display: flex;
      justify-content: center;
    }

    .app {
      width: min(560px, 100%);
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .back-link {
      display: inline-block;
      font-size: 0.8rem;
      color: rgba(255, 255, 255, 0.55);
      text-decoration: none;
      padding: 4px 0;
      letter-spacing: 0.03em;
      font-family: var(--font);
    }

    .back-link:hover { color: rgba(255, 255, 255, 0.8); }

    /* Liquid Glass Card Base */
    .card, header, .modal {
      background: var(--glass-bg);
      backdrop-filter: blur(var(--glass-blur)) saturate(150%);
      -webkit-backdrop-filter: blur(var(--glass-blur)) saturate(150%);
      border-radius: var(--radius);
      box-shadow: 
        0 8px 32px var(--glass-shadow),
        inset 0 1px 0 var(--glass-highlight),
        inset 0 -1px 0 rgba(255, 255, 255, 0.3);
      position: relative;
      overflow: visible;
      /* Rainbow shimmer border */
      border: 1px solid transparent;
      background-clip: padding-box;
    }

    /* Rainbow border effect via pseudo-element */
    .card::after, header::after {
      content: '';
      position: absolute;
      inset: -1px;
      border-radius: calc(var(--radius) + 1px);
      background: var(--rainbow-gradient);
      opacity: 0.3;
      z-index: -1;
      transition: opacity var(--transition-med);
    }

    .card:hover::after, header:hover::after {
      opacity: 0.45;
    }

    /* Subtle glass shine overlay */
    .card::before, header::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 50%;
      background: linear-gradient(
        180deg,
        rgba(255, 255, 255, 0.2) 0%,
        transparent 100%
      );
      pointer-events: none;
      border-radius: var(--radius) var(--radius) 0 0;
      z-index: 1;
      overflow: hidden;
    }

    /* Clip card content but allow button glows to extend */
    .card > *, header > * {
      position: relative;
      z-index: 2;
    }

    /* Page header - no card, just title */
    .page-header {
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 8px 4px 4px 4px;
    }

    .page-header .title-row {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .page-logo {
      width: 64px;
      height: 64px;
      object-fit: contain;
      flex-shrink: 0;
      filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.2));
    }

    .page-header h1 {
      font-family: 'Poiret One', var(--font);
      font-size: 26px;
      font-weight: 400;
      margin: 0;
      letter-spacing: 1px;
      color: #fff;
      text-shadow: 
        0 2px 10px rgba(13, 27, 62, 0.4),
        0 0 30px rgba(0, 229, 255, 0.25);
    }

    .page-header .sub {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      font-size: 13px;
      color: rgba(255, 255, 255, 0.85);
      line-height: 1.35;
      text-shadow: 0 1px 4px rgba(26, 35, 126, 0.2);
    }

    #setupCard .btn-card-help {
      position: absolute !important;
      top: 18px;
      right: 18px;
      left: auto;
      padding: 6px 12px;
      font-size: 12px;
      z-index: 10;
    }

    /* Legacy header styles for cards that need them */
    header {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 12px;
      padding: 16px;
    }

    header .title {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    header h1 {
      font-size: 20px;
      font-weight: 700;
      margin: 0;
      letter-spacing: 0.3px;
      color: var(--text);
    }

    header .sub {
      font-size: 12px;
      color: var(--text-muted);
      line-height: 1.35;
    }

    .chiprow {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: flex-end;
      align-items: center;
      margin-top: 2px;
    }

    /* Bubble Pill Chip */
    .chip {
      font-size: 12px;
      font-weight: 600;
      color: var(--text-muted);
      padding: 6px 14px;
      background: rgba(255, 255, 255, 0.45);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      border: 2px solid transparent;
      border-radius: var(--radius-pill);
      box-shadow: 
        0 2px 8px rgba(26, 35, 126, 0.1),
        inset 0 1px 0 rgba(255, 255, 255, 0.7);
      user-select: none;
      white-space: nowrap;
      position: relative;
    }

    .chip::after {
      content: '';
      position: absolute;
      inset: -2px;
      border-radius: var(--radius-pill);
      background: var(--rainbow-gradient);
      opacity: 0.25;
      z-index: -1;
    }

    /* Liquid Glass Button */
    .btn {
      appearance: none;
      font-family: var(--font);
      color: var(--text);
      background: rgba(255, 255, 255, 0.5);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 2px solid transparent;
      padding: 10px 14px;
      border-radius: 14px;
      font-weight: 600;
      font-size: 14px;
      cursor: pointer;
      user-select: none;
      box-shadow: 
        0 4px 16px rgba(26, 35, 126, 0.12),
        inset 0 1px 0 var(--glass-highlight);
      transition: 
        transform var(--transition-fast),
        box-shadow var(--transition-fast),
        background var(--transition-fast);
      position: relative;
      overflow: visible;
    }

    /* Rainbow border on buttons */
    .btn::after {
      content: '';
      position: absolute;
      inset: -2px;
      border-radius: 16px;
      background: var(--rainbow-gradient);
      opacity: 0.25;
      z-index: -1;
      transition: opacity var(--transition-fast);
    }

    .btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 50%;
      background: linear-gradient(
        180deg,
        rgba(255, 255, 255, 0.35) 0%,
        transparent 100%
      );
      pointer-events: none;
      border-radius: 12px 12px 0 0;
    }

    .btn:hover {
      background: rgba(255, 255, 255, 0.65);
      box-shadow: 
        0 6px 24px rgba(26, 35, 126, 0.18),
        0 0 20px rgba(0, 229, 255, 0.1),
        inset 0 1px 0 var(--glass-highlight);
    }

    .btn:hover::after {
      opacity: 0.45;
    }

    .btn:active {
      transform: scale(0.97);
      box-shadow: 
        0 2px 8px rgba(26, 35, 126, 0.1),
        inset 0 1px 0 var(--glass-highlight);
    }

    .btn:active::after {
      opacity: 0.6;
    }

    .btn.primary {
      background: rgba(255, 255, 255, 0.7);
      color: var(--sky-top);
    }

    .btn.primary::after {
      opacity: 0.5;
    }

    .btn.primary:hover {
      background: rgba(255, 255, 255, 0.85);
    }

    .btn.primary:hover::after {
      opacity: 0.7;
    }

    /* Large button variant */
    .btn-large {
      padding: 16px 32px;
      font-size: 16px;
      font-weight: 700;
      border-radius: 18px;
      width: 100%;
    }

    .btn-large::after {
      border-radius: 20px;
    }

    .btn.danger {
      background: rgba(255, 255, 255, 0.6);
      color: #b71c1c;
      font-weight: 700;
      border: 2px solid rgba(183, 28, 28, 0.3);
    }

    .btn.danger::after {
      background: linear-gradient(135deg, rgba(211, 47, 47, 0.5), rgba(183, 28, 28, 0.4));
      opacity: 0.5;
    }

    .btn.danger:hover {
      background: rgba(255, 255, 255, 0.75);
      border-color: rgba(183, 28, 28, 0.5);
    }

    .btn.danger:hover::after {
      opacity: 0.65;
    }

    .btn.ghost {
      background: rgba(255, 255, 255, 0.25);
      color: var(--text-muted);
    }

    .btn.ghost::after {
      opacity: 0.15;
    }

    .btn.ghost:hover {
      background: rgba(255, 255, 255, 0.4);
    }

    .btn.ghost:hover::after {
      opacity: 0.3;
    }

    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 16px;
    }

    .card {
      padding: 18px;
    }

    .controls {
      display: grid;
      grid-template-columns: 1fr;
      gap: 24px;
    }

    .controls > div {
      overflow: visible;
      text-align: center;
    }

    .controls .full {
      grid-column: 1 / -1;
    }

    label {
      font-size: 12px;
      font-weight: 600;
      color: var(--text-muted);
      display: block;
      margin-bottom: 8px;
      letter-spacing: 0.3px;
    }

    input[type="number"] {
      width: 100%;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.6);
      background: rgba(255, 255, 255, 0.5);
      backdrop-filter: blur(8px);
      color: var(--text);
      font-size: 15px;
      font-family: var(--font);
      outline: none;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.5);
      transition: border-color var(--transition-fast);
    }

    input[type="number"]:focus {
      border-color: rgba(135, 206, 235, 0.8);
    }

    /* Mini Bubble Preview for Pace */
    .pace-preview {
      width: 90px;
      height: 90px;
      margin: 0 auto 16px;
      position: relative;
      display: grid;
      place-items: center;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .pace-divider {
      width: 60%;
      max-width: 200px;
      height: 1px;
      margin: 0 auto 16px;
      background: linear-gradient(
        90deg,
        transparent 0%,
        rgba(255, 255, 255, 0.4) 20%,
        rgba(255, 255, 255, 0.4) 80%,
        transparent 100%
      );
    }

    .mini-bubble {
      width: 45%;
      height: 45%;
      position: relative;
      border-radius: 30% 70% 53% 47% / 50% 45% 55% 50%;
      background: 
        radial-gradient(ellipse 80% 80% at 50% 50%, 
          rgba(255, 255, 255, 0.15) 0%,
          transparent 70%),
        radial-gradient(circle at 30% 25%, 
          rgba(255, 255, 255, 0.4) 0%,
          transparent 25%),
        radial-gradient(circle at 60% 30%,
          rgba(0, 229, 255, 0.15) 0%,
          transparent 40%),
        rgba(255, 255, 255, 0.12);
      border: 1.5px solid rgba(255, 255, 255, 0.6);
      box-shadow: 
        0 0 20px rgba(0, 229, 255, 0.25),
        0 0 40px rgba(149, 117, 205, 0.15),
        inset 0 0 15px rgba(255, 255, 255, 0.2),
        inset 2px 2px 8px rgba(0, 229, 255, 0.15);
      transform: scale(var(--mini-s, 1));
      transition: transform var(--mini-dur, 2s) cubic-bezier(0.4, 0, 0.2, 1);
    }

    .mini-bubble::before {
      content: '';
      position: absolute;
      top: 10%;
      left: 18%;
      width: 30%;
      height: 22%;
      background: radial-gradient(
        ellipse 100% 100% at 50% 50%,
        rgba(255, 255, 255, 0.9) 0%,
        rgba(255, 255, 255, 0.5) 30%,
        transparent 70%
      );
      border-radius: 50%;
      transform: rotate(-20deg);
    }

    .mini-bubble::after {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: linear-gradient(
        135deg,
        rgba(0, 229, 255, 0.2) 0%,
        transparent 40%,
        transparent 60%,
        rgba(240, 98, 146, 0.15) 100%
      );
    }

    /* Segmented Control - Bubble Pills */
    .segmented {
      display: flex;
      justify-content: center;
      gap: 10px;
      overflow-x: auto;
      overflow-y: visible;
      -webkit-overflow-scrolling: touch;
      padding: 16px 16px;
      margin: -12px -16px;
    }

    .segmented button {
      flex: 0 0 auto;
      font-family: var(--font);
      border-radius: var(--radius-pill);
      padding: 10px 18px;
      border: 2px solid rgba(255, 255, 255, 0.4);
      background: rgba(255, 255, 255, 0.25);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      color: var(--text-soft);
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 
        0 2px 8px rgba(26, 35, 126, 0.1),
        inset 0 1px 0 rgba(255, 255, 255, 0.4);
      transition: 
        all var(--transition-fast),
        transform 0.1s ease;
      position: relative;
      overflow: visible;
    }

    /* Rainbow border glow for unselected (subtle) */
    .segmented button::after {
      content: '';
      position: absolute;
      inset: -2px;
      border-radius: var(--radius-pill);
      background: var(--rainbow-gradient);
      opacity: 0;
      z-index: -1;
      transition: opacity var(--transition-fast);
    }

    .segmented button:hover::after {
      opacity: 0.3;
    }

    .segmented button::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 45%;
      background: linear-gradient(
        180deg,
        rgba(255, 255, 255, 0.25) 0%,
        transparent 100%
      );
      pointer-events: none;
      opacity: 0;
      transition: opacity var(--transition-fast);
      border-radius: var(--radius-pill) var(--radius-pill) 0 0;
    }

    .segmented button.selected {
      background: rgba(255, 255, 255, 0.75);
      border-color: transparent;
      color: var(--sky-top);
      font-weight: 700;
      box-shadow: 
        0 4px 20px rgba(26, 35, 126, 0.25),
        0 0 30px rgba(0, 229, 255, 0.2),
        0 0 30px rgba(240, 98, 146, 0.15),
        inset 0 1px 0 rgba(255, 255, 255, 0.9);
    }

    /* Strong rainbow border on selected */
    .segmented button.selected::after {
      opacity: 0.7;
      animation: rainbowShimmer 3s linear infinite;
    }

    @keyframes rainbowShimmer {
      0% { filter: hue-rotate(0deg); }
      100% { filter: hue-rotate(360deg); }
    }

    .segmented button.selected::before {
      opacity: 1;
    }

    .segmented button:active {
      transform: scale(0.95);
    }

    .segmented button:active::after {
      opacity: 0.9;
    }

    .segmented button:focus-visible {
      outline: 2px solid rgba(0, 229, 255, 0.8);
      outline-offset: 2px;
    }

    .toggleGroup {
      display: flex;
      flex-direction: column;
      gap: 10px;
      padding-top: 2px;
    }

    .toggleRow {
      display: flex;
      align-items: center;
      gap: 10px;
      color: var(--text);
      font-size: 14px;
      font-weight: 500;
    }

    .toggleRow input {
      accent-color: #87CEEB;
      width: 18px;
      height: 18px;
    }

    .row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
    }

    .row .left {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }

    .muted {
      color: var(--text-soft);
      font-size: 12px;
    }

    .stage {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 10px;
      padding: 16px;
      min-height: 420px;
    }

    .stageTop {
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 10px;
    }

    .stageTop .meta {
      display: flex;
      flex-direction: column;
      gap: 4px;
      align-items: flex-start;
    }

    .stageTop .meta .big {
      font-size: 15px;
      font-weight: 700;
      letter-spacing: 0.3px;
      color: var(--text);
    }

    .stageTop .meta .small {
      font-size: 12px;
      color: var(--text-muted);
    }

    .stageTop .right {
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: flex-end;
      flex-wrap: wrap;
    }

    /* Breathing Area */
    .breathArea {
      width: min(340px, 75vw);
      aspect-ratio: 1 / 1;
      position: relative;
      display: grid;
      place-items: center;
      margin-top: 12px;
      user-select: none;
      touch-action: manipulation;
    }

    /* Outer decorative rings with rainbow shimmer */
    .ring {
      position: absolute;
      inset: 0;
      border-radius: 50%;
      border: 2px solid transparent;
      background: 
        linear-gradient(rgba(255,255,255,0.05), rgba(255,255,255,0.05)) padding-box,
        var(--rainbow-gradient) border-box;
      box-shadow: 
        0 0 40px rgba(0, 229, 255, 0.15),
        0 0 60px rgba(149, 117, 205, 0.1),
        inset 0 0 30px rgba(255, 255, 255, 0.1);
      animation: ringRainbow 12s linear infinite;
    }

    @keyframes ringRainbow {
      0% { filter: hue-rotate(0deg); opacity: 0.5; }
      50% { filter: hue-rotate(180deg); opacity: 0.7; }
      100% { filter: hue-rotate(360deg); opacity: 0.5; }
    }

    .ring2 {
      position: absolute;
      inset: 12%;
      border-radius: 50%;
      border: 1px solid transparent;
      background: 
        linear-gradient(rgba(255,255,255,0.03), rgba(255,255,255,0.03)) padding-box,
        var(--rainbow-gradient) border-box;
      opacity: 0.4;
      animation: ringRainbow 8s linear infinite reverse;
    }

    /* === SOAP BUBBLE === */
    .bubble {
      width: 44%;
      height: 44%;
      position: relative;
      
      /* Organic blob shape */
      border-radius: 30% 70% 53% 47% / 50% 45% 55% 50%;
      
      /* Translucent base with inner mist */
      background: 
        /* Inner mist/smoke effect */
        radial-gradient(ellipse 80% 80% at 50% 50%, 
          rgba(255, 255, 255, var(--mist-alpha)) 0%,
          transparent 70%),
        /* Highlight spots */
        radial-gradient(circle at 30% 25%, 
          rgba(255, 255, 255, 0.45) 0%,
          transparent 25%),
        radial-gradient(circle at 70% 75%, 
          rgba(255, 255, 255, 0.25) 0%,
          transparent 30%),
        /* Rainbow inner shimmer */
        radial-gradient(circle at 60% 30%,
          rgba(0, 229, 255, 0.12) 0%,
          transparent 40%),
        radial-gradient(circle at 40% 70%,
          rgba(240, 98, 146, 0.1) 0%,
          transparent 40%),
        /* Base transparency */
        rgba(255, 255, 255, 0.15);
      
      /* Rainbow rim glow */
      border: 2px solid transparent;
      background-clip: padding-box;
      box-shadow: 
        /* Outer rainbow glow */
        0 0 40px rgba(0, 229, 255, 0.3),
        0 0 60px rgba(149, 117, 205, 0.2),
        0 0 80px rgba(240, 98, 146, 0.15),
        0 0 100px rgba(255, 183, 77, 0.1),
        /* Inner rim highlights */
        inset 0 0 35px rgba(255, 255, 255, 0.25),
        inset 3px 3px 15px rgba(0, 229, 255, 0.2),
        inset -3px -3px 15px rgba(240, 98, 146, 0.15);
      
      backdrop-filter: blur(3px);
      -webkit-backdrop-filter: blur(3px);
      
      transform: scale(var(--s, 1));
      transition: 
        transform var(--dur, 2s) cubic-bezier(0.4, 0, 0.2, 1),
        border-radius 0.5s ease,
        --mist-alpha 0.5s ease;
    }

    /* Rainbow border ring */
    .bubble-ring {
      position: absolute;
      inset: -2px;
      border-radius: inherit;
      background: var(--rainbow-gradient);
      z-index: -1;
      opacity: 0.5;
      animation: bubbleRainbowRotate 8s linear infinite;
    }

    @keyframes bubbleRainbowRotate {
      0% { filter: hue-rotate(0deg); }
      100% { filter: hue-rotate(360deg); }
    }

    /* Specular highlight - main bright curved highlight with rainbow edge */
    .bubble::before {
      content: '';
      position: absolute;
      top: 8%;
      left: 15%;
      width: 38%;
      height: 28%;
      background: 
        radial-gradient(
          ellipse 100% 100% at 50% 50%,
          var(--bubble-highlight) 0%,
          rgba(255, 255, 255, 0.7) 25%,
          rgba(0, 229, 255, 0.3) 50%,
          transparent 70%
        );
      border-radius: 50%;
      transform: rotate(-20deg);
      opacity: 0.95;
    }

    /* Chromatic sheen / rainbow refraction effect */
    .bubble::after {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: 
        /* Multi-color rainbow sweep */
        linear-gradient(
          135deg,
          var(--bubble-sheen-1) 0%,
          rgba(100, 181, 246, 0.2) 15%,
          transparent 35%,
          transparent 65%,
          rgba(149, 117, 205, 0.15) 80%,
          var(--bubble-sheen-2) 90%,
          var(--bubble-sheen-3) 100%
        ),
        /* Secondary rainbow band */
        linear-gradient(
          -45deg,
          transparent 0%,
          transparent 40%,
          rgba(255, 183, 77, 0.15) 50%,
          rgba(240, 98, 146, 0.12) 60%,
          transparent 70%
        );
      mix-blend-mode: normal;
      opacity: 0.8;
      pointer-events: none;
    }

    /* Inhale state - more opaque, milky mist */
    .bubble.inhale {
      --mist-alpha: 0.25;
      border-radius: 35% 65% 58% 42% / 55% 40% 60% 45%;
    }

    /* Exhale state - clearer, more transparent */
    .bubble.exhale {
      --mist-alpha: 0.06;
      border-radius: 28% 72% 48% 52% / 45% 50% 50% 55%;
    }

    /* Hold/Retention state */
    .bubble.hold {
      border-radius: 50%;
      --mist-alpha: 0.15;
    }

    /* Retention mode - gentle pulse animation with rainbow */
    .bubble.retention {
      animation: retentionPulse 4s ease-in-out infinite;
    }

    .bubble.retention::before {
      animation: highlightDrift 6s ease-in-out infinite;
    }

    .bubble.retention::after {
      animation: rainbowSheenPulse 4s ease-in-out infinite;
    }

    @keyframes retentionPulse {
      0%, 100% { 
        transform: scale(var(--s, 1)); 
        box-shadow: 
          0 0 40px rgba(0, 229, 255, 0.3),
          0 0 60px rgba(149, 117, 205, 0.2),
          0 0 80px rgba(240, 98, 146, 0.15),
          inset 0 0 35px rgba(255, 255, 255, 0.25),
          inset 3px 3px 15px rgba(0, 229, 255, 0.2),
          inset -3px -3px 15px rgba(240, 98, 146, 0.15);
      }
      50% { 
        transform: scale(calc(var(--s, 1) * 1.03)); 
        box-shadow: 
          0 0 55px rgba(0, 229, 255, 0.4),
          0 0 80px rgba(149, 117, 205, 0.3),
          0 0 110px rgba(240, 98, 146, 0.2),
          0 0 130px rgba(255, 183, 77, 0.15),
          inset 0 0 45px rgba(255, 255, 255, 0.3),
          inset 4px 4px 20px rgba(0, 229, 255, 0.25),
          inset -4px -4px 20px rgba(240, 98, 146, 0.2);
      }
    }

    @keyframes rainbowSheenPulse {
      0%, 100% { opacity: 0.7; }
      50% { opacity: 0.9; }
    }

    @keyframes highlightDrift {
      0%, 100% {
        top: 8%;
        left: 15%;
        transform: rotate(-20deg);
      }
      50% {
        top: 10%;
        left: 18%;
        transform: rotate(-15deg);
      }
    }

    /* Inhale Hold state */
    .bubble.inhale-hold {
      --mist-alpha: 0.2;
      border-radius: 50%;
      animation: inhaleHoldPulse 3s ease-in-out infinite;
    }

    .bubble.inhale-hold::after {
      animation: rainbowSheenPulse 3s ease-in-out infinite;
    }

    @keyframes inhaleHoldPulse {
      0%, 100% { 
        transform: scale(var(--s, 1)); 
        box-shadow: 
          0 0 40px rgba(0, 229, 255, 0.3),
          0 0 60px rgba(149, 117, 205, 0.2),
          0 0 80px rgba(240, 98, 146, 0.15),
          inset 0 0 35px rgba(255, 255, 255, 0.25),
          inset 3px 3px 15px rgba(0, 229, 255, 0.2),
          inset -3px -3px 15px rgba(240, 98, 146, 0.15);
      }
      50% { 
        transform: scale(calc(var(--s, 1) * 1.02)); 
        box-shadow: 
          0 0 50px rgba(0, 229, 255, 0.35),
          0 0 75px rgba(149, 117, 205, 0.25),
          0 0 100px rgba(240, 98, 146, 0.18),
          inset 0 0 40px rgba(255, 255, 255, 0.28),
          inset 3px 3px 18px rgba(0, 229, 255, 0.22),
          inset -3px -3px 18px rgba(240, 98, 146, 0.18);
      }
    }

    .centerText {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 8px;
      text-align: center;
      padding: 24px;
      pointer-events: none;
    }

    .centerText .mode {
      font-size: 11px;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      color: var(--text-soft);
      font-weight: 600;
      transform: scale(var(--text-scale, 1));
      transition: transform var(--dur, 2s) cubic-bezier(0.4, 0, 0.2, 1);
    }

    .centerText .main {
      font-size: 44px;
      line-height: 1;
      font-weight: 700;
      letter-spacing: -0.02em;
      color: var(--text);
      text-shadow: 
        0 2px 10px rgba(255, 255, 255, 0.6),
        0 0 30px rgba(0, 229, 255, 0.15);
      transform: scale(var(--text-scale, 1));
      transition: transform var(--dur, 2s) cubic-bezier(0.4, 0, 0.2, 1);
    }

    .centerText .hint {
      font-size: 13px;
      color: var(--text-muted);
      line-height: 1.35;
      max-width: 24ch;
      transform: scale(var(--text-scale, 1));
      transition: transform var(--dur, 2s) cubic-bezier(0.4, 0, 0.2, 1);
    }

    /* Breathing text animation states */
    .centerText.breathing-inhale {
      --text-scale: 1.08;
    }

    .centerText.breathing-exhale {
      --text-scale: 0.95;
    }

    .centerText.breathing-hold {
      --text-scale: 1;
    }

    .progress {
      width: 100%;
      max-width: 560px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 8px;
    }

    .bar {
      height: 10px;
      border-radius: var(--radius-pill);
      background: rgba(255, 255, 255, 0.35);
      border: 1px solid rgba(255, 255, 255, 0.45);
      overflow: hidden;
      box-shadow: inset 0 1px 3px rgba(26, 35, 126, 0.1);
      position: relative;
    }

    .bar > div {
      height: 100%;
      width: 0%;
      background: linear-gradient(
        90deg,
        rgba(0, 229, 255, 0.7) 0%,
        rgba(100, 181, 246, 0.7) 25%,
        rgba(149, 117, 205, 0.7) 50%,
        rgba(240, 98, 146, 0.7) 75%,
        rgba(255, 183, 77, 0.7) 100%
      );
      border-radius: var(--radius-pill);
      transition: width 0.15s linear;
      box-shadow: 
        0 0 10px rgba(0, 229, 255, 0.4),
        0 0 20px rgba(149, 117, 205, 0.2);
    }

    .progressRow {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      color: var(--text-muted);
      font-size: 12px;
      font-weight: 500;
    }

    .history {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .historyHeader {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .historyHeader h2 {
      font-size: 15px;
      font-weight: 700;
      margin: 0;
      color: var(--text);
      letter-spacing: 0.2px;
    }

    .sessionList {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .sessionItem {
      padding: 12px;
      background: rgba(255, 255, 255, 0.35);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      border: 2px solid transparent;
      border-radius: 16px;
      display: flex;
      justify-content: space-between;
      gap: 10px;
      align-items: flex-start;
      box-shadow: 
        0 2px 12px rgba(26, 35, 126, 0.08),
        inset 0 1px 0 rgba(255, 255, 255, 0.5);
      position: relative;
      overflow: visible;
    }

    .sessionItem::after {
      content: '';
      position: absolute;
      inset: -2px;
      border-radius: 18px;
      background: var(--rainbow-gradient);
      opacity: 0.2;
      z-index: -1;
      transition: opacity var(--transition-fast);
    }

    .sessionItem:hover::after {
      opacity: 0.35;
    }

    .sessionItem .left {
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-width: 0;
    }

    .sessionItem .date {
      font-size: 12px;
      color: var(--text-muted);
    }

    .sessionItem .rounds {
      font-size: 14px;
      color: var(--text);
      font-weight: 600;
      line-height: 1.3;
      word-break: break-word;
    }

    .sessionItem .meta {
      font-size: 12px;
      color: var(--text-soft);
    }

    /* Modal */
    .modalBg {
      position: fixed;
      inset: 0;
      background: rgba(135, 180, 200, 0.4);
      backdrop-filter: blur(4px);
      -webkit-backdrop-filter: blur(4px);
      display: none;
      align-items: flex-end;
      justify-content: center;
      padding: 16px;
      padding-bottom: max(16px, env(safe-area-inset-bottom));
      z-index: 100;
    }

    .modal {
      width: min(560px, 100%);
      background: rgba(255, 255, 255, 0.85);
      border: 1px solid rgba(255, 255, 255, 0.9);
      border-radius: 24px;
      padding: 20px;
      box-shadow: 
        0 20px 60px rgba(100, 120, 150, 0.25),
        inset 0 1px 0 rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(20px) saturate(150%);
      -webkit-backdrop-filter: blur(20px) saturate(150%);
    }

    .modal h3 {
      margin: 0 0 8px 0;
      font-size: 16px;
      font-weight: 700;
      color: var(--text);
    }

    .modal p {
      margin: 0 0 12px 0;
      color: var(--text-muted);
      font-size: 14px;
      line-height: 1.45;
    }

    .modal .actions {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      flex-wrap: wrap;
    }

    .kbd {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      padding: 3px 10px;
      border-radius: 8px;
      border: 1px solid transparent;
      background: 
        linear-gradient(rgba(255,255,255,0.6), rgba(255,255,255,0.6)) padding-box,
        var(--rainbow-gradient) border-box;
      color: var(--text);
      font-size: 12px;
      white-space: nowrap;
      box-shadow: 
        0 1px 4px rgba(26, 35, 126, 0.1),
        0 0 8px rgba(0, 229, 255, 0.1);
    }

    @media (min-width: 520px) {
      .controls {
        grid-template-columns: 1fr;
      }
      .controls .full {
        grid-column: 1 / -1;
      }
    }

    /* Reduced motion */
    @media (prefers-reduced-motion: reduce) {
      .bubble,
      .mini-bubble {
        transition: transform 0.3s ease;
      }
      
      .bubble.retention,
      .bubble.inhale-hold {
        animation: none;
      }
      
      .bubble.retention::before,
      .bubble.retention::after,
      .bubble.inhale-hold::after {
        animation: none;
      }
      
      .ring, .ring2 {
        animation: none;
      }
      
      .segmented button.selected::after {
        animation: none;
      }
      
      .centerText .mode,
      .centerText .main,
      .centerText .hint {
        transition: transform 0.3s ease;
      }
      
      .btn,
      .segmented button,
      input,
      .bar > div {
        transition: none;
      }
      
      @keyframes retentionPulse {
        0%, 100% { transform: scale(var(--s, 1)); }
      }
      
      @keyframes highlightDrift {
        0%, 100% { top: 8%; left: 15%; }
      }
      
      @keyframes inhaleHoldPulse {
        0%, 100% { transform: scale(var(--s, 1)); }
      }
      
      @keyframes rainbowShimmer {
        0%, 100% { filter: none; }
      }
      
      @keyframes ringRainbow {
        0%, 100% { filter: none; opacity: 0.5; }
      }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="app">
      <a class="back-link" href="../">&larr; vibes</a>
      <div class="page-header">
        <div class="title-row">
          <img src="./icon.png" alt="" class="page-logo" />
          <h1>Breath Retention</h1>
        </div>
        <div class="sub">
          Guided breaths → Exhale hold timer → 15s inhale hold → Next round
        </div>
      </div>

      <div class="grid">
        <div class="card" id="setupCard">
          <button class="btn ghost btn-card-help" id="btnHelp" type="button">Help</button>
          <div class="controls">
            <div>
              <div class="pace-preview">
                <div class="mini-bubble" id="miniBubble"></div>
              </div>
              <div class="pace-divider"></div>
              <label id="labelInhale">Pace</label>
              <div id="inhale" class="segmented" role="radiogroup" aria-labelledby="labelInhale"></div>
            </div>
            <div>
              <label id="labelBreaths">Breaths per round</label>
              <div id="breaths" class="segmented" role="radiogroup" aria-labelledby="labelBreaths"></div>
            </div>
            <div>
              <label id="labelRounds">Rounds</label>
              <div id="rounds" class="segmented" role="radiogroup" aria-labelledby="labelRounds"></div>
            </div>
            <div class="full" style="margin-top: 8px;">
              <button class="btn primary btn-large" id="btnStart" type="button">Start Session</button>
              <button class="btn btn-large" id="btnResume" type="button" style="display:none;">Resume</button>
            </div>
          </div>
        </div>

        <div class="card" id="stageCard" style="display:none;">
          <div class="stage">
            <div class="stageTop">
              <div class="meta">
                <div class="big" id="stageTitle">Breathing</div>
                <div class="small" id="stageMeta">Round 1 of 3</div>
              </div>
              <div class="right">
                <button class="btn" id="btnPause" type="button">Pause</button>
                <button class="btn ghost" id="btnEndRetention" type="button" style="display:none;">End Retention</button>
                <button class="btn danger" id="btnStop" type="button">Stop</button>
              </div>
            </div>

            <div class="breathArea" id="tapArea" aria-label="Tap area">
              <div class="ring"></div>
              <div class="ring2"></div>
              <div class="bubble" id="bubble"></div>
              <div class="centerText">
                <div class="mode" id="modeLabel">INHALE</div>
                <div class="main" id="mainNumber">1</div>
                <div class="hint" id="hintText">Follow the bubble. Last breath ends with a full exhale.</div>
              </div>
            </div>

            <div class="progress">
              <div class="bar"><div id="barFill"></div></div>
              <div class="progressRow">
                <div id="progressLeft">Breath 1 / 30</div>
                <div id="progressRight">Inhale 4s • Exhale 4s</div>
              </div>
            </div>

            <div class="row" style="width:100%; margin-top:6px;">
              <div class="muted" id="tapHint">During retention: double-tap the circle to finish.</div>
              <div class="muted" id="timeHint"></div>
            </div>
          </div>
        </div>

        <div class="card">
          <div class="history">
            <div class="historyHeader">
              <h2>Saved Sessions</h2>
              <div class="left">
                <button class="btn ghost" id="btnImport" type="button">Import</button>
                <button class="btn ghost" id="btnExport" type="button">Export</button>
                <button class="btn ghost" id="btnClearHistory" type="button">Clear</button>
                <input id="fileInput" type="file" accept="application/json" style="display:none" />
              </div>
            </div>
            <div class="sessionList" id="sessionList"></div>
            <div class="muted" id="historyEmpty" style="display:none;">No sessions yet. Finish a session to save it here.</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="modalBg" id="modalBg" role="dialog" aria-modal="true">
    <div class="modal" id="modal">
      <h3 id="modalTitle">Help</h3>
      <p id="modalBody"></p>
      <div class="actions" id="modalActions"></div>
    </div>
  </div>

  <script>
    const STORAGE_KEY = "vibe.breath-retention.v1";
    const $ = (id) => document.getElementById(id);

    function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

    function formatTimeMs(ms){
      const totalSec = Math.max(0, Math.floor(ms / 1000));
      const m = Math.floor(totalSec / 60);
      const s = totalSec % 60;
      if (m > 0) return `${m}:${String(s).padStart(2,"0")}`;
      return `${s}s`;
    }

    function isoToNice(iso){
      try{
        const d = new Date(iso);
        return d.toLocaleString(undefined, {
          weekday: "short", year: "numeric", month: "short", day: "numeric",
          hour: "numeric", minute: "2-digit"
        });
      }catch(_){ return iso; }
    }

    function download(filename, text){
      const blob = new Blob([text], {type:"application/json"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    const defaultState = () => ({
      config: {
        breaths: 30,
        inhaleSec: 2,
        exhaleSec: 2,
        rounds: 3,
        inhaleHoldSec: 15,
        keepAwake: true,
        soundsOn: false,
        hapticsOn: true
      },
      history: [],
      draft: null
    });

    let state = defaultState();

    function loadState(){
      try{
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return;
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed !== "object") return;

        state = defaultState();
        if (parsed.config) Object.assign(state.config, parsed.config);
        if (Array.isArray(parsed.history)) state.history = parsed.history.slice(0, 200);
        if (parsed.draft) state.draft = parsed.draft;
      }catch(e){
        console.warn("Failed to load:", e);
      }
    }

    function saveState(){
      try{
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      }catch(e){
        console.error(e);
        alert("Could not save. Storage may be full or blocked.");
      }
    }

    const els = {
      breaths: $("breaths"),
      inhale: $("inhale"),
      rounds: $("rounds"),
      miniBubble: $("miniBubble"),
      btnStart: $("btnStart"),
      btnResume: $("btnResume"),
      btnPause: $("btnPause"),
      btnEndRetention: $("btnEndRetention"),
      btnStop: $("btnStop"),
      setupCard: $("setupCard"),
      stageCard: $("stageCard"),
      stageTitle: $("stageTitle"),
      stageMeta: $("stageMeta"),
      modeLabel: $("modeLabel"),
      mainNumber: $("mainNumber"),
      hintText: $("hintText"),
      tapHint: $("tapHint"),
      timeHint: $("timeHint"),
      bubble: $("bubble"),
      barFill: $("barFill"),
      progressLeft: $("progressLeft"),
      progressRight: $("progressRight"),
      tapArea: $("tapArea"),
      sessionList: $("sessionList"),
      historyEmpty: $("historyEmpty"),
      btnClearHistory: $("btnClearHistory"),
      btnHelp: $("btnHelp"),
      btnExport: $("btnExport"),
      btnImport: $("btnImport"),
      fileInput: $("fileInput"),
      modalBg: $("modalBg"),
      modalTitle: $("modalTitle"),
      modalBody: $("modalBody"),
      modalActions: $("modalActions")
    };

    const paceOptions = [
      {label:"Slow", value:3},
      {label:"Medium", value:2},
      {label:"Fast", value:1.3},
    ];
    const breathOptions = Array.from({length: 5}, (_, i) => {
      const value = 20 + (i * 5);
      return {label: String(value), value};
    });
    const roundOptions = [1, 2, 3, 4, 5].map(value => ({label: String(value), value}));

    // Mini bubble preview animation
    let miniBubbleInterval = null;
    let miniBubblePhase = 'inhale';
    
    function startMiniBubbleAnimation(paceSec) {
      // Clear any existing animation
      if (miniBubbleInterval) {
        clearInterval(miniBubbleInterval);
      }
      
      const bubble = els.miniBubble;
      if (!bubble) return;
      
      // Set transition duration
      bubble.style.setProperty('--mini-dur', `${paceSec}s`);
      
      // Start with inhale (grow)
      miniBubblePhase = 'inhale';
      bubble.style.setProperty('--mini-s', '1.6');
      
      // Toggle between inhale and exhale
      miniBubbleInterval = setInterval(() => {
        if (miniBubblePhase === 'inhale') {
          miniBubblePhase = 'exhale';
          bubble.style.setProperty('--mini-s', '0.85');
        } else {
          miniBubblePhase = 'inhale';
          bubble.style.setProperty('--mini-s', '1.6');
        }
      }, paceSec * 1000);
    }
    
    function stopMiniBubbleAnimation() {
      if (miniBubbleInterval) {
        clearInterval(miniBubbleInterval);
        miniBubbleInterval = null;
      }
    }

    function renderSegmentedControl(containerEl, options, selectedValue, onChange){
      containerEl.innerHTML = "";
      let currentValue = selectedValue;
      for (const opt of options){
        const btn = document.createElement("button");
        btn.type = "button";
        btn.textContent = opt.label;
        btn.dataset.value = String(opt.value);
        const isSelected = opt.value === currentValue;
        btn.className = isSelected ? "selected" : "";
        btn.setAttribute("aria-pressed", isSelected ? "true" : "false");
        btn.addEventListener("click", () => {
          if (opt.value === currentValue) return;
          currentValue = opt.value;
          onChange(opt.value);
          for (const b of containerEl.querySelectorAll("button")){
            const val = parseFloat(b.dataset.value);
            const selected = val === currentValue;
            b.classList.toggle("selected", selected);
            b.setAttribute("aria-pressed", selected ? "true" : "false");
          }
        });
        containerEl.appendChild(btn);
      }
    }

    function refreshSetupControls(){
      renderSegmentedControl(els.breaths, breathOptions, state.config.breaths, (value) => {
        updateConfigValue("breaths", value);
      });
      renderSegmentedControl(els.inhale, paceOptions, state.config.inhaleSec, (value) => {
        updatePace(value);
        startMiniBubbleAnimation(value);
      });
      renderSegmentedControl(els.rounds, roundOptions, state.config.rounds, (value) => {
        updateConfigValue("rounds", value);
      });
      // Start mini bubble animation with current pace
      startMiniBubbleAnimation(state.config.inhaleSec);
    }

    function closeModal(){
      els.modalBg.style.display = "none";
      els.modalActions.innerHTML = "";
    }

    function openModal({title, body, actions}){
      els.modalTitle.textContent = title;
      els.modalBody.innerHTML = body;
      els.modalActions.innerHTML = "";

      for (const a of actions){
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "btn " + (a.variant || "");
        btn.textContent = a.label;
        btn.onclick = () => { if (a.onClick) a.onClick(); };
        els.modalActions.appendChild(btn);
      }
      els.modalBg.style.display = "flex";
    }

    els.modalBg.addEventListener("click", (e) => {
      if (e.target === els.modalBg) closeModal();
    });

    const Stage = {
      IDLE: "idle",
      STARTING: "starting",
      BREATHING: "breathing",
      RETENTION: "retention",
      INHALE_HOLD: "inhale_hold",
      COMPLETE: "complete",
      PAUSED: "paused"
    };

    let runtime = {
      stage: Stage.IDLE,
      pausedFrom: null,
      cfg: null,

      roundIndex: 0,
      breathIndex: 0,
      phase: "inhale",
      phaseStartedAt: 0,
      nextPhaseAt: 0,

      retentionStartedAt: 0,
      retentionElapsedMs: 0,
      inhaleHoldLeftMs: 0,

      retentionsMs: [],

      tickHandle: null,
      lastTapAt: 0
    };
    let wakeLockSentinel = null;
    let audioCtx = null;

    function isSessionActive(){
      return runtime.stage === Stage.STARTING ||
        runtime.stage === Stage.BREATHING ||
        runtime.stage === Stage.RETENTION ||
        runtime.stage === Stage.INHALE_HOLD;
    }

    // Update bubble state classes for CSS-driven visual changes
    function updateBubbleState(state, phase) {
      els.bubble.classList.remove('inhale', 'exhale', 'hold', 'retention', 'inhale-hold');
      
      // Also update center text breathing animation
      const centerText = document.querySelector('.centerText');
      centerText.classList.remove('breathing-inhale', 'breathing-exhale', 'breathing-hold');
      
      if (state === Stage.BREATHING) {
        els.bubble.classList.add(phase); // 'inhale' or 'exhale'
        // Add breathing text animation
        if (phase === 'inhale') {
          centerText.classList.add('breathing-inhale');
        } else {
          centerText.classList.add('breathing-exhale');
        }
      } else if (state === Stage.RETENTION) {
        els.bubble.classList.add('hold', 'retention');
        centerText.classList.add('breathing-hold');
      } else if (state === Stage.INHALE_HOLD) {
        els.bubble.classList.add('hold', 'inhale-hold');
        centerText.classList.add('breathing-hold');
      }
    }

    async function requestWakeLock(){
      if (!state.config.keepAwake) return;
      if (document.hidden) return;
      if (!("wakeLock" in navigator)) return;
      if (wakeLockSentinel) return;
      try{
        wakeLockSentinel = await navigator.wakeLock.request("screen");
        wakeLockSentinel.addEventListener("release", () => {
          wakeLockSentinel = null;
        });
      }catch(e){
        console.warn("Wake lock failed:", e);
      }
    }

    function releaseWakeLock(){
      if (wakeLockSentinel){
        wakeLockSentinel.release();
        wakeLockSentinel = null;
      }
    }

    function updateWakeLockForState(){
      if (!state.config.keepAwake || document.hidden){
        releaseWakeLock();
        return;
      }
      if (runtime.stage === Stage.PAUSED || runtime.stage === Stage.IDLE || runtime.stage === Stage.COMPLETE){
        releaseWakeLock();
        return;
      }
      requestWakeLock();
    }

    function initAudioContext(){
      if (!audioCtx){
        const AudioCtor = window.AudioContext || window.webkitAudioContext;
        if (AudioCtor) audioCtx = new AudioCtor();
      }
      if (audioCtx && audioCtx.state === "suspended"){
        audioCtx.resume();
      }
    }

    function playClick(){
      if (!state.config.soundsOn) return;
      if (!audioCtx) return;
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = "triangle";
      osc.frequency.setValueAtTime(740, now);
      gain.gain.setValueAtTime(0.0, now);
      gain.gain.linearRampToValueAtTime(0.12, now + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start(now);
      osc.stop(now + 0.09);
    }

    function doHaptic(pattern){
      if (!state.config.hapticsOn) return;
      if (navigator.vibrate) navigator.vibrate(pattern);
    }

    function cueFeedback(kind){
      if (kind === "transition"){
        playClick();
        doHaptic(10);
        return;
      }
      if (kind === "retention"){
        playClick();
        doHaptic([12, 20, 12]);
        return;
      }
      if (kind === "inhale_hold"){
        playClick();
        doHaptic([15, 25, 15]);
      }
    }

    function setChip(text){
      // Status chip removed from UI - no-op
    }

    function showSetup(){
      els.setupCard.style.display = "";
      els.stageCard.style.display = "none";
      els.btnResume.style.display = state.draft ? "" : "none";
      // Resume mini bubble animation
      startMiniBubbleAnimation(state.config.inhaleSec);
    }

    function showStage(){
      els.setupCard.style.display = "none";
      els.stageCard.style.display = "";
      // Stop mini bubble animation during session
      stopMiniBubbleAnimation();
    }

    function hardResetDraft(){
      state.draft = null;
      saveState();
      els.btnResume.style.display = "none";
    }

    function snapshotConfigFromUI(){
      const cfg = {
        breaths: state.config.breaths,
        inhaleSec: state.config.inhaleSec,
        exhaleSec: state.config.exhaleSec,
        rounds: state.config.rounds,
        inhaleHoldSec: 15,
        keepAwake: state.config.keepAwake,
        soundsOn: state.config.soundsOn,
        hapticsOn: state.config.hapticsOn
      };
      cfg.breaths = clamp(cfg.breaths, 20, 40);
      cfg.rounds = clamp(cfg.rounds, 1, 5);
      cfg.inhaleSec = clamp(cfg.inhaleSec, 1, 3);
      cfg.exhaleSec = clamp(cfg.exhaleSec, 1, 3);
      return cfg;
    }

    function updateConfigValue(key, value){
      state.config[key] = value;
      state.config.breaths = clamp(state.config.breaths, 20, 40);
      state.config.rounds = clamp(state.config.rounds, 1, 5);
      state.config.inhaleSec = clamp(state.config.inhaleSec, 1, 3);
      state.config.exhaleSec = clamp(state.config.exhaleSec, 1, 3);
      state.config.inhaleHoldSec = 15;
      saveState();
    }

    function updatePace(value){
      state.config.inhaleSec = value;
      state.config.exhaleSec = value;
      updateConfigValue("inhaleSec", value);
    }

    function updateConfigFromUI(){
      const cfg = snapshotConfigFromUI();
      state.config = cfg;
      saveState();
    }

    function makeDraft(){
      state.draft = {
        createdAt: new Date().toISOString(),
        cfg: runtime.cfg,
        roundIndex: runtime.roundIndex,
        breathIndex: runtime.breathIndex,
        stage: runtime.stage,
        phase: runtime.phase,
        retentionElapsedMs: runtime.retentionElapsedMs,
        inhaleHoldLeftMs: runtime.inhaleHoldLeftMs,
        retentionsMs: runtime.retentionsMs
      };
      saveState();
      els.btnResume.style.display = "";
    }

    function clearTick(){
      if (runtime.tickHandle){
        clearInterval(runtime.tickHandle);
        runtime.tickHandle = null;
      }
    }

    function startTick(){
      clearTick();
      runtime.tickHandle = setInterval(tick, 33);
    }

    function resetRuntime(){
      clearTick();
      runtime = {
        stage: Stage.IDLE,
        pausedFrom: null,
        cfg: null,
        roundIndex: 0,
        breathIndex: 0,
        phase: "inhale",
        phaseStartedAt: 0,
        nextPhaseAt: 0,
        retentionStartedAt: 0,
        retentionElapsedMs: 0,
        inhaleHoldLeftMs: 0,
        retentionsMs: [],
        tickHandle: null,
        lastTapAt: 0
      };
      els.bubble.classList.remove("hold", "inhale", "exhale", "retention", "inhale-hold");
      els.bubble.style.setProperty("--s", "1");
      els.bubble.style.setProperty("--dur", "2s");
      els.barFill.style.width = "0%";
      els.timeHint.textContent = "";
      els.tapHint.textContent = "During retention: double-tap the circle to finish.";
      els.btnEndRetention.style.display = "none";
      setChip("Ready");
      updateWakeLockForState();
    }

    function renderStageHeader(){
      const r = runtime.roundIndex + 1;
      const R = runtime.cfg.rounds;
      els.stageMeta.textContent = `Round ${r} of ${R}`;
    }

    function setBubbleScale(scale, durSec){
      els.bubble.style.setProperty("--dur", `${durSec}s`);
      els.bubble.style.setProperty("--s", String(scale));
      // Also sync text breathing animation duration
      const centerText = document.querySelector('.centerText');
      centerText.style.setProperty("--dur", `${durSec}s`);
    }

    function renderBreathingUI(){
      const cfg = runtime.cfg;
      const b = runtime.breathIndex;
      const B = cfg.breaths;

      els.stageTitle.textContent = "Breathing";
      renderStageHeader();
      
      // Update bubble state for CSS
      updateBubbleState(Stage.BREATHING, runtime.phase);

      els.modeLabel.textContent = runtime.phase.toUpperCase();
      els.mainNumber.textContent = String(b);

      els.hintText.textContent = (b === B)
        ? "Last breath: exhale fully, then hold."
        : "Follow the bubble. Keep it comfortable.";

      const pct = clamp((b-1) / B, 0, 1) * 100;
      els.barFill.style.width = `${pct}%`;

      els.progressLeft.textContent = `Breath ${b} / ${B}`;
      els.progressRight.textContent = `Inhale ${cfg.inhaleSec}s • Exhale ${cfg.exhaleSec}s`;

      els.tapHint.textContent = "Tap not needed—just follow along.";
      els.timeHint.textContent = "";
      els.btnEndRetention.style.display = "none";
    }

    function renderRetentionUI(){
      els.stageTitle.textContent = "Retention";
      renderStageHeader();
      
      // Update bubble state for CSS
      updateBubbleState(Stage.RETENTION);

      els.modeLabel.textContent = "HOLD (EXHALE)";
      const now = performance.now();
      const elapsed = runtime.retentionElapsedMs + (now - runtime.retentionStartedAt);
      els.mainNumber.textContent = formatTimeMs(elapsed);

      els.hintText.textContent = "Double-tap the circle when you need to breathe.";
      els.tapHint.textContent = "Double-tap the circle or use End retention.";
      els.timeHint.textContent = "Then you'll take one big inhale and hold it.";
      els.btnEndRetention.style.display = "";

      const sec = Math.floor(elapsed/1000);
      const pct = ((sec % 60) / 60) * 100;
      els.barFill.style.width = `${pct}%`;

      els.progressLeft.textContent = `Retention: ${formatTimeMs(elapsed)}`;
      els.progressRight.textContent = `Round ${runtime.roundIndex+1}`;
    }

    function renderInhaleHoldUI(){
      els.stageTitle.textContent = "Inhale Hold";
      renderStageHeader();
      
      // Update bubble state for CSS
      updateBubbleState(Stage.INHALE_HOLD);

      els.modeLabel.textContent = "HOLD (INHALE)";
      els.mainNumber.textContent = formatTimeMs(runtime.inhaleHoldLeftMs);

      els.hintText.textContent = "Big inhale. Hold gently.";
      els.tapHint.textContent = "Auto-continues to next round.";
      els.timeHint.textContent = "";
      els.btnEndRetention.style.display = "none";

      const total = runtime.cfg.inhaleHoldSec * 1000;
      const pct = clamp(1 - (runtime.inhaleHoldLeftMs / total), 0, 1) * 100;
      els.barFill.style.width = `${pct}%`;

      els.progressLeft.textContent = `Inhale hold: ${formatTimeMs(runtime.inhaleHoldLeftMs)}`;
      els.progressRight.textContent = `Next: breathing`;
    }

    function renderPausedUI(){
      els.stageTitle.textContent = "Paused";
      renderStageHeader();
      els.modeLabel.textContent = "PAUSED";
      els.hintText.textContent = "Tap Resume to continue.";
      els.tapHint.textContent = "";
      els.timeHint.textContent = "";
      setBubbleScale(1.2, 0.2);
      els.btnEndRetention.style.display = "none";
      // Remove animation classes when paused
      els.bubble.classList.remove('retention', 'inhale-hold');
    }

    function renderStartingUI(){
      els.stageTitle.textContent = "Get Ready";
      renderStageHeader();
      
      els.bubble.classList.remove('inhale', 'exhale', 'hold', 'retention', 'inhale-hold');
      
      els.modeLabel.textContent = "STARTING";
      els.mainNumber.textContent = "...";
      els.hintText.textContent = "Exhale and relax. We'll begin shortly.";
      
      els.barFill.style.width = "0%";
      els.progressLeft.textContent = "Preparing...";
      els.progressRight.textContent = `${runtime.cfg.breaths} breaths • ${runtime.cfg.rounds} rounds`;
      
      els.tapHint.textContent = "";
      els.timeHint.textContent = "";
      els.btnEndRetention.style.display = "none";
    }

    function startStartingPhase(){
      runtime.stage = Stage.STARTING;
      
      const paceSec = runtime.cfg.inhaleSec; // Match the user's chosen pace
      const paceMs = paceSec * 1000;
      
      // Start at mid-size
      setBubbleScale(1.2, 0.1);
      renderStartingUI();
      
      // After a brief moment, animate down to exhale size
      setTimeout(() => {
        if (runtime.stage === Stage.STARTING) {
          setBubbleScale(0.82, paceSec * 0.8); // 80% of pace for the shrink animation
        }
      }, 100);
      
      // After pace duration, begin breathing
      setTimeout(() => {
        if (runtime.stage === Stage.STARTING) {
          startBreathingRound();
        }
      }, paceMs);
      
      setChip("Starting");
      updateWakeLockForState();
    }

    function startBreathingRound(){
      runtime.stage = Stage.BREATHING;
      runtime.breathIndex = 1;
      runtime.phase = "inhale";
      runtime.phaseStartedAt = performance.now();
      runtime.nextPhaseAt = runtime.phaseStartedAt + runtime.cfg.inhaleSec * 1000;

      setBubbleScale(0.82, 0.05);
      renderBreathingUI();
      requestAnimationFrame(() => {
        if (runtime.stage === Stage.BREATHING && runtime.phase === "inhale"){
          setBubbleScale(1.85, runtime.cfg.inhaleSec);
        }
      });
      cueFeedback("transition");
      makeDraft();
      setChip("In session");
      updateWakeLockForState();
    }

    function advanceBreathingPhase(now){
      const cfg = runtime.cfg;

      if (runtime.phase === "inhale"){
        runtime.phase = "exhale";
        runtime.phaseStartedAt = now;
        runtime.nextPhaseAt = now + cfg.exhaleSec * 1000;
        setBubbleScale(0.82, cfg.exhaleSec);
        renderBreathingUI();
        cueFeedback("transition");
        makeDraft();
        return;
      }

      if (runtime.breathIndex >= cfg.breaths){
        startRetention();
        return;
      }

      runtime.breathIndex += 1;
      runtime.phase = "inhale";
      runtime.phaseStartedAt = now;
      runtime.nextPhaseAt = now + cfg.inhaleSec * 1000;
      setBubbleScale(1.85, cfg.inhaleSec);
      renderBreathingUI();
      cueFeedback("transition");
      makeDraft();
    }

    function startRetention(){
      runtime.stage = Stage.RETENTION;
      runtime.retentionElapsedMs = 0;
      runtime.retentionStartedAt = performance.now();
      setBubbleScale(1.12, 0.25);
      renderRetentionUI();
      cueFeedback("retention");
      makeDraft();
    }

    function finishRetention(){
      const now = performance.now();
      const elapsed = runtime.retentionElapsedMs + (now - runtime.retentionStartedAt);
      runtime.retentionsMs[runtime.roundIndex] = Math.max(0, Math.floor(elapsed));

      runtime.stage = Stage.INHALE_HOLD;
      runtime.inhaleHoldLeftMs = runtime.cfg.inhaleHoldSec * 1000;
      setBubbleScale(1.20, 0.2);
      renderInhaleHoldUI();
      cueFeedback("inhale_hold");
      makeDraft();
    }

    function advanceInhaleHold(deltaMs){
      runtime.inhaleHoldLeftMs = Math.max(0, runtime.inhaleHoldLeftMs - deltaMs);
      renderInhaleHoldUI();
      makeDraft();

      if (runtime.inhaleHoldLeftMs <= 0){
        if (runtime.roundIndex + 1 < runtime.cfg.rounds){
          runtime.roundIndex += 1;
          startBreathingRound();
        } else {
          completeSession();
        }
      }
    }

    function completeSession(){
      runtime.stage = Stage.COMPLETE;
      clearTick();
      setChip("Complete");
      releaseWakeLock();

      const cfg = runtime.cfg;
      const session = {
        id: crypto.randomUUID ? crypto.randomUUID() : String(Date.now()) + "-" + Math.random().toString(16).slice(2),
        createdAt: new Date().toISOString(),
        cfg: {...cfg},
        retentionsMs: runtime.retentionsMs.slice(0, cfg.rounds)
      };
      state.history.unshift(session);
      state.history = state.history.slice(0, 100);
      hardResetDraft();
      saveState();
      renderHistory();

      const roundLines = session.retentionsMs.map((ms, i) => `Round ${i+1}: <span class="kbd">${formatTimeMs(ms)}</span>`).join("<br>");
      openModal({
        title: "Session saved",
        body: `
          <div style="margin-bottom:8px; color: var(--text); font-weight:700;">
            Retentions
          </div>
          <div style="line-height:1.55; margin-bottom:10px;">
            ${roundLines}
          </div>
          <div class="muted">
            Config: ${cfg.breaths} breaths • In ${cfg.inhaleSec}s / Out ${cfg.exhaleSec}s • ${cfg.rounds} rounds
          </div>
        `,
        actions: [
          {label:"Done", variant:"primary", onClick: () => { closeModal(); showSetup(); resetRuntime(); } }
        ]
      });
    }

    function tick(){
      if (runtime.stage === Stage.PAUSED) return;

      const now = performance.now();

      if (runtime.stage === Stage.BREATHING){
        if (now >= runtime.nextPhaseAt){
          advanceBreathingPhase(now);
        }
        return;
      }

      if (runtime.stage === Stage.RETENTION){
        renderRetentionUI();
        return;
      }

      if (runtime.stage === Stage.INHALE_HOLD){
        const dt = 33;
        advanceInhaleHold(dt);
        return;
      }
    }

    function beginSessionFromConfig(cfg){
      resetRuntime();
      runtime.cfg = cfg;
      runtime.roundIndex = 0;
      runtime.retentionsMs = new Array(cfg.rounds).fill(0);
      showStage();
      startStartingPhase();
      startTick();
      els.btnPause.textContent = "Pause";
    }

    function pause(){
      if (runtime.stage === Stage.PAUSED) return;

      runtime.pausedFrom = runtime.stage;
      runtime.stage = Stage.PAUSED;

      if (runtime.pausedFrom === Stage.RETENTION){
        const now = performance.now();
        runtime.retentionElapsedMs += (now - runtime.retentionStartedAt);
      }

      clearTick();
      renderPausedUI();
      makeDraft();
      els.btnPause.textContent = "Resume";
      setChip("Paused");
      updateWakeLockForState();
    }

    function resume(){
      if (runtime.stage !== Stage.PAUSED) return;

      runtime.stage = runtime.pausedFrom || Stage.BREATHING;
      const now = performance.now();

      if (runtime.stage === Stage.STARTING){
        // Restart the starting phase
        startStartingPhase();
        runtime.pausedFrom = null;
        els.btnPause.textContent = "Pause";
        return;
      }

      if (runtime.stage === Stage.BREATHING){
        runtime.phaseStartedAt = now;
        runtime.nextPhaseAt = now + ((runtime.phase === "inhale" ? runtime.cfg.inhaleSec : runtime.cfg.exhaleSec) * 1000);

        const dur = (runtime.phase === "inhale" ? runtime.cfg.inhaleSec : runtime.cfg.exhaleSec);
        setBubbleScale(runtime.phase === "inhale" ? 1.85 : 0.82, dur);
        renderBreathingUI();
      }

      if (runtime.stage === Stage.RETENTION){
        runtime.retentionStartedAt = now;
        renderRetentionUI();
      }

      if (runtime.stage === Stage.INHALE_HOLD){
        renderInhaleHoldUI();
      }

      runtime.pausedFrom = null;
      startTick();
      els.btnPause.textContent = "Pause";
      setChip("In session");
      makeDraft();
      updateWakeLockForState();
    }

    function stopSession(confirm=true){
      const doStop = () => {
        clearTick();
        resetRuntime();
        showSetup();
        setChip("Ready");
        hardResetDraft();
        releaseWakeLock();
      };

      if (!confirm){
        doStop();
        return;
      }

      openModal({
        title: "Stop session?",
        body: `This will discard the in-progress session (it won't be saved to history).`,
        actions: [
          {label:"Cancel", onClick: () => closeModal() },
          {label:"Stop", variant:"danger", onClick: () => { closeModal(); doStop(); } }
        ]
      });
    }

    function resumeDraft(){
      const d = state.draft;
      if (!d) return;

      resetRuntime();
      runtime.cfg = d.cfg;
      runtime.roundIndex = d.roundIndex;
      runtime.breathIndex = d.breathIndex;
      runtime.stage = d.stage;
      runtime.phase = d.phase;

      runtime.phaseStartedAt = performance.now();
      runtime.nextPhaseAt = runtime.phaseStartedAt + ((runtime.phase === "inhale" ? runtime.cfg.inhaleSec : runtime.cfg.exhaleSec) * 1000);

      runtime.retentionElapsedMs = d.retentionElapsedMs || 0;
      runtime.retentionsMs = Array.isArray(d.retentionsMs) ? d.retentionsMs : [];
      runtime.inhaleHoldLeftMs = d.inhaleHoldLeftMs || (runtime.cfg.inhaleHoldSec * 1000);

      showStage();

      if (runtime.stage === Stage.BREATHING){
        const dur = (runtime.phase === "inhale" ? runtime.cfg.inhaleSec : runtime.cfg.exhaleSec);
        setBubbleScale(runtime.phase === "inhale" ? 1.85 : 0.82, dur);
        renderBreathingUI();
      } else if (runtime.stage === Stage.RETENTION){
        runtime.retentionStartedAt = performance.now();
        setBubbleScale(1.12, 0.25);
        renderRetentionUI();
      } else if (runtime.stage === Stage.INHALE_HOLD){
        setBubbleScale(1.20, 0.2);
        renderInhaleHoldUI();
      } else {
        runtime.stage = Stage.BREATHING;
        startBreathingRound();
      }

      startTick();
      els.btnPause.textContent = "Pause";
      setChip("In session");
      updateWakeLockForState();
    }

    function onTapArea(){
      if (runtime.stage !== Stage.RETENTION) return;

      const now = Date.now();
      const delta = now - runtime.lastTapAt;
      runtime.lastTapAt = now;

      if (delta > 0 && delta < 350){
        finishRetention();
      }
    }

    function onStopPressed(){
      stopSession(true);
    }

    function renderHistory(){
      els.sessionList.innerHTML = "";
      if (!state.history.length){
        els.historyEmpty.style.display = "";
        return;
      }
      els.historyEmpty.style.display = "none";

      for (const s of state.history.slice(0, 20)){
        const div = document.createElement("div");
        div.className = "sessionItem";

        const left = document.createElement("div");
        left.className = "left";

        const date = document.createElement("div");
        date.className = "date";
        date.textContent = isoToNice(s.createdAt);

        const rounds = document.createElement("div");
        rounds.className = "rounds";
        const list = (s.retentionsMs || []).map(ms => formatTimeMs(ms)).join(" • ");
        rounds.textContent = list || "(no data)";

        const meta = document.createElement("div");
        meta.className = "meta";
        const cfg = s.cfg || {};
        meta.textContent = `${cfg.breaths || "?"} breaths • In ${cfg.inhaleSec || "?"}s / Out ${cfg.exhaleSec || "?"}s • ${cfg.rounds || "?"} rounds`;

        left.appendChild(date);
        left.appendChild(rounds);
        left.appendChild(meta);

        const right = document.createElement("div");
        right.className = "left";

        const del = document.createElement("button");
        del.className = "btn ghost";
        del.type = "button";
        del.textContent = "Delete";
        del.onclick = () => {
          openModal({
            title: "Delete session?",
            body: `This removes it from this device.`,
            actions: [
              {label:"Cancel", onClick: () => closeModal()},
              {label:"Delete", variant:"danger", onClick: () => {
                closeModal();
                state.history = state.history.filter(x => x.id !== s.id);
                saveState();
                renderHistory();
              }}
            ]
          });
        };

        right.appendChild(del);

        div.appendChild(left);
        div.appendChild(right);
        els.sessionList.appendChild(div);
      }
    }

    function doExport(){
      const payload = {
        version: 1,
        exportedAt: new Date().toISOString(),
        data: {
          config: state.config,
          history: state.history
        }
      };
      download(`breath-retention-export-${new Date().toISOString().slice(0,10)}.json`, JSON.stringify(payload, null, 2));
    }

    function doImportFile(file){
      const reader = new FileReader();
      reader.onload = () => {
        try{
          const parsed = JSON.parse(reader.result);
          const data = parsed?.data || parsed;

          if (data?.config) state.config = {...state.config, ...data.config};
          if (Array.isArray(data?.history)) state.history = data.history.slice(0, 100);

          state.draft = null;
          saveState();

          refreshSetupControls();

          renderHistory();

          openModal({
            title: "Imported",
            body: "Your config and saved sessions were imported.",
            actions: [{label:"Done", variant:"primary", onClick: () => closeModal()}]
          });
        }catch(e){
          console.error(e);
          alert("Import failed: invalid JSON.");
        }
      };
      reader.readAsText(file);
    }

    function wireUI(){
      refreshSetupControls();

      els.btnStart.addEventListener("click", () => {
        initAudioContext();
        updateConfigFromUI();
        const cfg = {...state.config};
        beginSessionFromConfig(cfg);
      });

      els.btnResume.addEventListener("click", () => {
        initAudioContext();
        resumeDraft();
      });

      els.btnPause.addEventListener("click", () => {
        if (runtime.stage === Stage.PAUSED) resume();
        else pause();
      });

      els.btnEndRetention.addEventListener("click", () => {
        if (runtime.stage === Stage.RETENTION) finishRetention();
      });

      els.btnStop.addEventListener("click", () => onStopPressed());

      els.tapArea.addEventListener("click", () => onTapArea());
      els.tapArea.addEventListener("touchend", (e) => { e.preventDefault(); onTapArea(); }, {passive:false});

      els.btnClearHistory.addEventListener("click", () => {
        openModal({
          title: "Clear all history?",
          body: `This deletes all saved sessions on this device.`,
          actions: [
            {label:"Cancel", onClick: () => closeModal()},
            {label:"Clear", variant:"danger", onClick: () => {
              closeModal();
              state.history = [];
              saveState();
              renderHistory();
            }}
          ]
        });
      });

      els.btnHelp.addEventListener("click", () => {
        openModal({
          title: "How to use",
          body: `
            <p>
              <b>Setup:</b> Choose your desired breaths, pace, and rounds. Then tap <span class="kbd">Start Session</span>.
            </p>
            <p>
              <b>Breathing:</b> Breathe in and out, following the expanding/contracting bubble.
              On your <b>last breath</b>, exhale and begin retention.
            </p>
            <p>
              <b>Retention:</b> The timer counts up as you hold. When you're ready to inhale, <b>Double-tap</b> the circle or press <span class="kbd">End Retention</span>
            </p>
            <p>
              <b>Inhale hold:</b> Take a big inhale and hold for 15 more seconds. Then start the next round.
            </p>
            <p>
              <b>Saving:</b> When the session ends, retentions are saved locally. Use <span class="kbd">Export</span> and <span class="kbd">Import</span> to move data.
            </p>
            <p class="muted">
              Note: This is a simple timer/guide, not medical advice—keep it comfortable.
            </p>
          `,
          actions: [{label:"Done", variant:"primary", onClick: () => closeModal()}]
        });
      });

      els.btnExport.addEventListener("click", () => doExport());
      els.btnImport.addEventListener("click", () => els.fileInput.click());
      els.fileInput.addEventListener("change", () => {
        const f = els.fileInput.files?.[0];
        els.fileInput.value = "";
        if (f) doImportFile(f);
      });

      window.addEventListener("beforeunload", (e) => {
        if (runtime.stage !== Stage.IDLE && runtime.stage !== Stage.COMPLETE){
          e.preventDefault();
          e.returnValue = "";
        }
      });

      document.addEventListener("visibilitychange", () => {
        updateWakeLockForState();
      });
    }

    function init(){
      loadState();

      state.config.breaths = clamp(state.config.breaths || 30, 20, 40);
      state.config.rounds = clamp(state.config.rounds || 3, 1, 5);
      state.config.inhaleSec = clamp(state.config.inhaleSec || 2, 1, 3);
      state.config.exhaleSec = clamp(state.config.exhaleSec || state.config.inhaleSec || 2, 1, 3);
      state.config.exhaleSec = state.config.inhaleSec;
      state.config.inhaleHoldSec = 15;
      state.config.keepAwake = state.config.keepAwake !== false;
      state.config.soundsOn = !!state.config.soundsOn;
      state.config.hapticsOn = state.config.hapticsOn !== false;

      wireUI();
      renderHistory();

      if (state.draft){
        els.btnResume.style.display = "";
        setChip("Resume available");
      } else {
        els.btnResume.style.display = "none";
        setChip("Ready");
      }

      showSetup();
    }

    // Save draft once per second during retention (avoid constant writes)
    let lastRetentionSaveSec = -1;
    setInterval(() => {
      if (runtime.stage === Stage.RETENTION){
        const now = performance.now();
        const elapsed = runtime.retentionElapsedMs + (now - runtime.retentionStartedAt);
        const sec = Math.floor(elapsed/1000);
        if (sec !== lastRetentionSaveSec){
          lastRetentionSaveSec = sec;
          makeDraft();
        }
      } else {
        lastRetentionSaveSec = -1;
      }
    }, 200);

    init();
  </script>
</body>
</html>
